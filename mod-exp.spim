    .data
strn: .asciiz "\n"
str1: .asciiz "Entradas invalidas."
str2: .asciiz "O modulo nao eh primo."
str3: .asciiz "Saida."
limit: .word 65535
prime: .word 251

    .text
main:
    li $v0, 5		# read int
    syscall
    move $s0, $v0	# $s0 = b
    li $v0, 5
    syscall
    move $s1, $v0 	# $s1 = e
    li $v0, 5
    syscall
    move $s2, $v0	# $s2 = m

    jal verify_values
    jal eh_primo

    li $v0, 10
    syscall

verify_values:
    lw $t2, limit   # $t2 = 65535

    # testing if($s0 >= 0 && $s0 <65535)
    slt $t0, $s0, $t2
    beq $t0, $zero, bad_entry
    slti $t0, $s0, 0
    bne $t0, $zero, bad_entry

    # testing if($s1 >= 0 && $s1 <65535)
    slt $t0, $s1, $t2
    beq $t0, $zero, bad_entry
    slti $t0, $s1, 0
    bne $t0, $zero, bad_entry

    # testing if($s2 >= 0 && $s2 <65535)
    slt $t0, $s2, $t2
    beq $t0, $zero, bad_entry
    slti $t0, $s2, 0
    bne $t0, $zero, bad_entry

    jr $ra
bad_entry:
    li $v0, 4
    la $a0, str1
    syscall
    la $a0, strn
    syscall
    li $v0, 10
    syscall

eh_primo:
    li $t0, 1
    beq $s2, $t0, num_eh # if M == 1, num_eh
    li $t0, 2
    bne $s2, $t0, par_verif # if M == 2, return
    jr $ra
par_verif:
    div $s2, $t0 
    mfhi $t1
    beq $t1, $zero, num_eh  # verifica numeros pares
# possível verificar números multiplos de 5 também
    li $t0, 3
    bne $s2, $t0, mod_check # inicializa o loop no 3
    jr $ra
eh_primo_verif:
    sltu $t1, $t0, $s2
    bne $t1, $zero, mod_check # se $t0 >= M, entao é primo
    jr $ra
mod_check:
    div $s2, $t0
    mfhi $t1
    beq $t1, $zero, num_eh # se $t1 == 0, nao é primo
prox_numero:
    addi $t0, $t0, 2 # de 2 em 2 para apenas impares
    j eh_primo_verif
num_eh:
    li $v0, 4
    la $a0, str2
    syscall
    la $a0, strn
    syscall
    li $v0, 10
    syscall

calc_exp:
    beq $s1, $zero, imprime_saida
    div $s0, $s2
    mfhi $t0    # b %= m
calc_exp_loop:
    beq $s1, $zero, imprime_saida
    #multu $s0, 
    j calc_exp_loop
imprime_saida:
    li $v0, 4
    la $a0, str3
    syscall
    la $a0, strn
    syscall
    li $v0, 10
    syscall